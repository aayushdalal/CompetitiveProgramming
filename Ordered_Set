#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define MOD 1000000007
#define int long long

// Compiler optimization directives

// Fast I/O setup
static const auto harsh = []()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

// --- Simple and reliable custom hash for unordered_map/unordered_set ---
struct SimpleHash {
    size_t operator()(long long x) const {
        x ^= x >> 16;
        x *= 31;
        return x;
    }
};
// Usage example: unordered_map<int,int,SimpleHash> mp;

// --- PBDS (Policy-Based Data Structure) setup ---
typedef tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
// find_by_order(x) -> returns iterator to element at index x (0-based)
// order_of_key(x) -> returns count of elements strictly smaller than x
// Example: pbds s; s.insert(10); s.insert(20); cout << *s.find_by_order(1); // 20

// You can make a template version as well:
// template<class T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// Then use like: oset<pair<int,int>> s;

void solve(){
    
}

typedef tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

long long countMajoritySubarrays(vector<int>& nums, int target) {
        //we need count of subarray whose prefixsum is less than current subarray sum
        for(int &a:nums){
            if(a==target)a=1;
            else a=-1;
        }
        int n=nums.size();
        for(int i=1;i<n;i++){
            nums[i]+=nums[i-1];
        }
        long long ans=0;
        ordered_set s;
        s.insert({0,0});
        for(int i=0;i<n;i++){
            ans+=s.order_of_key({nums[i],-1});// dont do i here as we may have found nums[i] before and then that piar will be smaller than current pair but we only need larger pair so we do -1, now for sure we will get prefixsum that are less than prefixsum=nums[i]
            s.insert({nums[i],i});
        }
        return ans;
}
int32_t main()
{
    fastio;

//#ifndef ONLINE_JUDGE
//freopen("input.txt", "r", stdin);
//freopen("output.txt", "w", stdout);
//#endif

    int tc = 1;
    cin >> tc;
    while (tc--)
    {
        solve();
    }
    return 0;
}
