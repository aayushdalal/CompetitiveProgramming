//https://codeforces.com/contest/2166/problem/C
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define MOD 1000000007
#define int long long

// Compiler optimization directives

// Fast I/O setup
static const auto harsh = []()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

// --- Simple and reliable custom hash for unordered_map/unordered_set ---
struct SimpleHash {
    size_t operator()(long long x) const {
        x ^= x >> 16;
        x *= 31;
        return x;
    }
};
// Usage example: unordered_map<int,int,SimpleHash> mp;

// --- PBDS (Policy-Based Data Structure) setup ---
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
// find_by_order(x) -> returns iterator to element at index x (0-based)
// order_of_key(x) -> returns count of elements strictly smaller than x
// Example: pbds s; s.insert(10); s.insert(20); cout << *s.find_by_order(1); // 20

// You can make a template version as well:
// template<class T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// Then use like: oset<pair<int,int>> s;
class node{
    public:
    int val;
    node *left;
    node *right;
    node(int val){
        this->val=val;
        this->left=NULL;
        this->right=NULL;
    }
};
class mycomp{
    public:
    bool operator()(node*a,node*b)const{
        if (a->val == b->val) return a < b; 
        return (a->val)<(b->val);
        
    }
};
void solve(){
    int n;
    cin>>n;
    vector<node*>v(n);
    for(int i=0;i<n;i++){
        int a;
        cin>>a;
        v[i]=new node(a);
    }
    for(int i=0;i<n;i++){
        if(i<n-1){
            v[i]->right=v[i+1];
        }
        else v[i]->right=v[0];

        if(i>0)v[i]->left=v[i-1];
        else v[i]->left=v[n-1];
    }
    int ans=0;
    multiset<node*,mycomp>minheap;
    for(int i=0;i<n;i++)minheap.insert(v[i]);

    while(minheap.size()!=1){
        node*front=*minheap.begin();
        minheap.erase(minheap.begin());
        int leftchild=front->left->val;
        int rightchild=front->right->val;
        if(leftchild<rightchild){
            //choose left
            ans+=leftchild;
            front->left->right=front->right;
            front->right->left=front->left;
        }
        else{
            ans+=rightchild;
            front->left->right=front->right;
            front->right->left=front->left;
        }
    }
    cout<<ans<<"\n";
}

//simpler
void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    
    vector<int> ans;
    for (int i = 0; i < n; i++) {
        ans.push_back(max(a[i], a[(i + 1) % n]));
    }
    
    int sum = accumulate(ans.begin(), ans.end(), 0LL);
    int mx = *max_element(ans.begin(), ans.end());
    
    cout << sum - mx << endl;
}
int32_t main()
{
    fastio;

//#ifndef ONLINE_JUDGE
//freopen("input.txt", "r", stdin);
//freopen("output.txt", "w", stdout);
//#endif

    int tc = 1;
    cin >> tc;
    while (tc--)
    {
        solve();
    }
    return 0;
}
